New goal: Use java to rebuild tiny-obj into tiny-j
22 Jan 2022
---
14 toc dot-c files
	src/debug.c   src/facsym.c    src/link.c         src/stack.c    src/var.c
	src/dialog.c  src/factor.c    src/machineCall.c  src/toc.c      src/xray.c
	src/expr.c    src/fileRead.c  src/platform.c     src/tocMain.c
tests in test* dirs and files
	green == bash scripts
	blue  == dirs
tiny-c/test.c may be better study for order of coding
test number:
	1..4: newvar, dumpVarTab
	5: symname, dumpName
	6: _varAlloc, dumpVarTab
	7: _lit
	8: _decl
	9: iProperty  [ReadFile, reads property file]
[to be continued, 77 tests]
==============	
Studying var.c. Goal is understanding needed publics.
	6:   void newfun()
	25:  void fundone()
	78:  void newvar(class,type,len,passed)   <<== constructor
	158: var* addrval()
privates:
	_copyArgValue, _allocSpace, _canon, canon, _addrval, _addrval_all
5 dumps:
	165..211  [Val, funEntry, Fun, Var, VarTab]
==============	
Probably not needed: FileRead, debug
==============
Studying stack.c
	38:   void pushst(,,,)
	52:   stackentry* popst()
	64:   int topdiff()   [used only by reln, tc~474]
	72:   int toptoi()
	106:  void pushk(datum)
	114:  void pushPtr(datum)
	121:  void pushone()
	124:  void pushzero()
privates:
	stuffCopy (one use)
4 dumps:
	3..33 [stackEntry, stack, popTop, top, ]
NOTICE stack always pops int
----------------------------------

Sun, Jan 23
ISSUE: how to implement stuff. It must carry a typeless. C uses a union. There
is no such thing in java. And I bet you cannot do a pointer. It would have
to be a subscript into an array. How to implement...
	char foo(99), ptr(0); ptr=foo      ???
This issue may be fatal to the goal.
Maybe tj can have references instead of pointers. ptr(0) syntax is class 1
in tc and toc. Actually tc pointers ARE references. They have type, size, len.
How to implement stuff ??? What goes onto a stack? You pop a stack and then
examine what you got, type,size,len,class,value. value is the bugger.
	Maybe stuff has all except value, and value is a subclass. HMM!
Datum would be type stuff, and usage of a datum would dig out its value by 
downcasting. Better implement this first as it may be the critical issue to
solve. Do var and stack first. [History repeats itself.]
---
Issue: files. tc.c was separated into a few files in tiny-obj. What are they?
$ ls src/*.c
	src/debug.c   src/facsym.c    src/link.c         src/stack.c    src/var.c
	src/dialog.c  src/factor.c    src/machineCall.c  src/toc.c      src/xray.c
	src/expr.c    src/fileRead.c  src/platform.c     src/tocMain.c
This seems a better structure, especially for public classes. One possibility is
to use tiny-obj as our code source for java, maybe leaving out the object 
extensions. Probably easier is to split tc.c into above. tiny-c has 9 dot-c 
files, (omiting 2 test codes.) Above is 14, but it includes enhancements like xray.
Difference:  facsym, link, factor, xray, expr, platform...
		toc					tc			sizes(K)
	src/debug.c			.debug
	src/facsym.c    	.				 2
	src/link.c         	.				 9
	src/stack.c    		.stack
	src/var.c			.var
	src/dialog.c  		.dialog
	src/factor.c    	.				 9
	src/machineCall.c  	.machineCall
	src/toc.c      		.tc				10, 23
	src/xray.c			.
	src/expr.c    		.				 5
	src/fileRead.c  	.FileRead
	src/platform.c     	.
	src/tocMain.c		.tcMain
xray has no comments. What is it?
	Its a debugging aid, an extension to MC 0. DO LATER, maybe.
---
toc split   -->  facsym, link, factor, expr
=======
Plan tc:
	Use tc code, cp from tiny-c read-only
	split tc to match the toc split into *.java files
	define stuff & descendants, ival, cval, and maybe sval for strings.
	Optionally put value there, too.
=============
var vs stackentry...
	struct stackentry { 
		int class; int lvalue; Type type; 
		union stuff value; 
	};
	struct var { 
		char name[VLEN+1]; int class; Type type; int len; int brkpt;
		union stuff value; 
	};
var reflects what is in the declaration. StackEntry what is
needed for an expression. Notice var has value, which may be
a C pointer to a string. var.value points into value space. 
For class 1 char it	points into the tc program text.
	Can these two decls be made cleaner. In java cannot coerce ints <-> ptrs. 
Use subclasses for value intead of union. For now focus on stack version, and
value is in each subclass Including ref to text. 
---------------------

Tue Jan 25
Working on Stuff.java. char and int OK, string probably needs change when its
role is better understood. Did git init, and committed.
	Cval/Ival classes have toInt(), Sval has toString().
	java Stuff  ->  "7 81 foo-bar"  [3 lines]
java String is immutable. StringBuffer is not. Which should I use for quoted
strings? The tc code in String means cannot change trailing quote to null, but
must extract the string. The former was always a kluge. Hmm.
---
Next goal: stack
---------------------

Wed Jan 26
setting CLASSPATH...
	As root:  $ . ./setClassPath   << my bash script
			$ echo $CLASSPATH
			~/Projects/tiny-j/classes
---
From: https://stackoverflow.com/questions/45309470/how-to-set-environment-variable-classpath-and-noclassdeffounderror-on-linux
    javac ABMain.java
    mv AAA.class ./sub/AAA.class
    mv BBB.class ./sub/BBB.class
    java -cp ./sub:. ABMain
The idea seems to be: 
	subordinate stuff move to ./sub, (I would use ./classes)
	main class stays in tiny-j, and is launched from there
	the -cp means class path with subordinate. NOTE the :.
	I would use:    java -cp ./classes:. Stuff
		and eventually Stack and ultimately tj
	CLASSPATH env var seems to not be involved at all.
---
STATUS of classpath nightmare...
	export CLASSPATH=/home/.../tiny-j/classes     WORKS at user level
	echo $CLASSPATH                               confirms
	erase all *.class files
	javac *.java                         CLASSPATH ignored
	mv *.class classes                   all including Stuff.class
	java Stuff                           runs fine
javac ignores the CLASSPATH, java uses it OK.
How to avoid the mv step? How to make javac embrace the CLASSPATH?
	Found a -cp javac option, man javac, scroll down 2 hits.
	It doesn't work...
NOW HAVE script: ./jc, which does the compile and move.
---
Goal: toptoi and other convenience push/pops.
	A design issue is where to draw the line between Stuff and C primitives.
	For example stack.c uses primitives and builds approprate wrapper as a
	struct stackentry. The line is drawn INSIDE of stack push/pops. The C data
	is needed in expression. Maybe expr() does the unwrapping. But pushone(),
	etc is handy for reln(). Hmm.
		Maybe keep Stuff wrappers a bit higher simplifying push/pop. 
		Add pushk(int), pushone(), etc when needed in expression.
	AND DITTO the funtab stuff. 
	AND eq() needs to resolve an lvalue. Might want to do that soon.
---
Ultra simplified stack.java has just the stack itself, push, pop.
How about expression next. A bit of parsing needed.
---
EXPRESSION...
In tiny-obj expr.c has these fcns...
	asgn
	eq
	reln
	expr
	term
	and uses factor.c 
These are in tc.c~459..675, total 269 lines.
Starting with that code for expr.java.
Doing konst first.  ISSUES:
	_findEOS must return pr subscript
	_mustFind ditto
	DECIDE where are fname,lname converted to a Stuff?
		konst, or new fcn immediately after ?
		Simplest is konst, then return a Stuff which is ample.
Plan: get it to work returning code, than add conversion to Stuff.
STATUS: Wed 7pm: Working on PT.java. 
---------------------

Thur, Jan 27
How to grep with brackets. Use primes AND backslash...
	grep 'pr\[' *.java
	grep '\*cursor' *.java
---
ISSUE: where to put char pr[TJ.PRSIZE] ?
	TJ has manefest constants and some globals, e.g. cursor.
	Stack has the stack.
	cursor,first,last and pr and all parsing should be together.
	PT is parsing tools.
	I'm thinking one big file for pr and all code needing access to it.
	PR.java ???
	Where does main go? java TJ? java TC? 
	When packed into a jar, how is the jar executed ?
		java -jar /../pathToApp
---
import <packageName>
	package statement must be first in file except for leading comments
	or blank lines. My package name would be tgibson37.tinyc.
The package statement in Stuff hides its main, and it wont run.
How to execute a package produced by one file? 
---------------------

Fri, Jan 28
New ~/Projects/Java/Play folder. Goal is to experiment with package directive.
========================= (hiatus) ============================

Sun, Feb 6
Moved tiny-j under ~/Projects/Java.

See ~/Projects/Java/Play/PackageFun for above goal. 
Instead of a makefile I used a few very short bash scripts: 
	setClassPath, jc (compile all), run, clean (remove class files). 
And package name is /tg37/pkgTry. I now understand packaging much better.

STATUS:
	must compile in specific order, so using jc to capture that order.
	So far 2 compiles, the rest fail. NEEDS study why.
		BECAUSE latest changes were not finished/debugged.
pr not declared anywhere. Most usages are in PT.java (parse tools). 
	Where to put? TJ so far is constants. It has NO prereq classes.
		DONE. And stack[] defined in stack.java, too.
---------------------

Mon, Feb 7
GOAL today: retrofit those scripts to tiny-j and package all.
Bit of confusion. The work is in dir Java/tiny-j. The package is tg37/tinyc.
And: going straight to new dir structure.
---
x	move/modify scripts
x		setClassPath
x		clean
x		jc
x		run
x	create dir structure
	edit src to belong to /tg37/tiny, and store under src dir
	test this mess
STATUS:
	6:20am TJ compiles using new dir structure, jc works, clean works
	6:35am Stuff compiles, runs OK 	
	That brings me to the run status of old file structure, ~155 above. 
---
Goal:
	Write Stack test main.
		Stub runs, needs actual test code.
		Const probably needed.
Const
	NEEDS PT
	compiling from cmd line (#'d out in jc)
	konst() should return a Stuff, or null. 
PT
	Needs xcmnt and other x data.
---
Plan:
	Get PT working first
	Then Const
	Then use to write Stack.main tests
---
New Methods: code in PT.java 
	to replace strncmp...
		boolean match(String s1, String s2, int n) {   // arbitrary strings
		boolean matcur(String token){                  // to cursor 
New shell scripts:  gj sym, gc sym  --  Grep java/C code
---------------------

Tue, Feb 8
STATUS
	./setClassPath  sets to this works cls
	./jc compiles Stuff,TJ,Stack
	./clean removes class files
	./run runs Stack.main which is a stub. No test code yet.
	./gc sym greps the tiny-c source for sym
	./gj sym ditto for java source
Current work
	Using $ javac -d cls src/tg37/tinyc/PT.java to java-ize PT
	strncmp PT~17, replace with appropriate match(): ~15,21
WONDERING if TJ should define tools like eset() and the match()'s ???
	They use lots of TJ-dot, e.g. TJ.xcmnt.
	The goal of a tool class is to make algorithms easy to code. All those
		TJ-dots make for messy typing AND reading.
	In effect merge TJ and PT.
	A downside is all the parse tools become TJ.lit(TJ.xcmt)), for example.
	So include that, too. Conclusion is layered code does not map into
	classes unless you want to XX-dot everything. 
EXTEND is the solution. PT extends TJ. All the TJ-dots disappear !!!
	Higher layers extend lower layers, adding to them. But watch out names.
	You lose the separation of name spaces. Not an issue for this project.
---
pr+cursor doesnt work. pr is char[], cursor is int.
pr.substr(cursor) may work if pr is a String.
STRING pr: Read file line-at-a-time appending into StringBuffer. Return 
buffer.toString() which is done efficiently, no copying. Now tokenizing is
done using substring, compareto, and more.
---
It seems to me that matching will be easier to write if all the pr text is
an array of String tokens. How hard is it to write a tokenizer? One pass over 
the read buffer into String token[]. Can I expand an array? Assume yes for now.
First char is:
	comment --  pass over
	alpha  --  continue through alphanums
	const  --  continue thru the constant
	()[]   --  single char
	ops    --  test for 2 chars
Do a line at a time. 
	FUTURE: 1st byte is token type.
		matching []'s point to each other.
		fcn call points to the fcn decl.   MAYBE MORE
---------------------

Wed, Feb 9
Working on Token.java
ArrayList~502 has addAll(Collection)
STATUS 1 pm: parses alphas & numbers. COMMITTED. And tidied. 
NEED to add more types:
	constants, operators, structure: {}[](), puctuation, other. Is that all ???
	Add one at a time and let the tokenizer decide.
AND: A small struct with just the type and token is what should be in token[].
QUESTIONS: should I continue with arrays or should I use ArrayList ???
---------------------

Thur, Feb 10
Back from Tokenizer, which is now in ../Java/Tokenizer. A copy is here as
a package member.

~282 STATUS is handy
	~290 has javac for PT, PT extends TJ. NEED TJ.class
	cls has only Token.class
ALL fixed, ./jc now compiles PT with errors  <<==  AGENDA
./jc now writes error file and does head -n 40
---------------------

Fri, Feb 11
PT compiles. No main.
STATUS
	./jc compiles Stuff,TJ,Stack,PT  <<== EVERYTHING
	Token was moved to Projects/Java/Tokenizer, not in any package.
Const next...
	konst returns Type, not boolean. Type==0 means false.
---
Thoughts: 
Building a parse tree might be fun. A [] block would contain ALL the
statments withing the block. An fcn defn would have a Stuff of type FCN with 
return type, name, args, body: 4 elements. Constants would be type and value: 
ints would be parsed once at parse time, and value held as a java/C/whatever
integer.
---
Structures:
	TJ <- PT <- Const 
	Stuff <- [S,C,I]val
	Stack
Expression Parser~393..675
	asgn, expr, term, factor, konst  
Rename Const.java -> Expr.java and do all 5 classes.
Combine Stack and Stuff. OR put stuff into TJ.
        ???        ???        ???        ???
PLAN:
x	Rename Const -> Expr
x		Get it to compile
		Design/code tests in main()
	Add expression stack but factor does ONLY constant.
	USES pushk & toptoi, so Stack gets tested, too.
---------------------

Sat, Feb 12
A choice of goals: 
	Work on tokenizer project until it can tokenize a tiny-c, C, or Java program.
	Finish the java version of tiny-c.
	The former gives me a nice publishable tool. The later a workable tiny-c.
	But I can do tiny-c on my laptop, maybe. And the latter may be useful in
	the former, giving it more purpose.
Today I think I will do the tokenizer.
---------------------

Thur, Mar 24   --   (six week hiatus)
With my C platform crashed I return to java. Recalling the status here...
	No cmds file, but gc, gj, jc
	jc compiles PT.java and Expr.java, and had also done Stuff & Stack.java.
	gc/j greps code in two places: ../../tiny-c and ./src/tg37/tinyc/*.java
	Setup: setClassPath sets to local cls dir only.
Studying ~50 above, Stuff. 8080 code everything was an int when popped, but
stack data described it. So Stuff is what is pushed/popped. 
tc's class changed to dtod (distance to datum), 0 or 1. Avoids confusion.
	3 subclasses: Sval,Cval,Ival hold respect. These ARE the values, there is
	no value space allocated in pr.
at ~184 above...
	java Stack               <<-- "could not find..."
	java tg37.tinyc.Stack    <<-- WORKS
---
$ java tg37.tinyc.Expr
running Expr.main0 11
 ~9 ~109             <<==   FREEZes
 	This must be my most recent status for tiny-c. 
 		~109 is in PT.java, rem.
 		pr code is set in Expr~46 to:   "  77  foo  "
 		~109 is while loop in rem() and ~123 when loop is done doesn't print.
so konst() must call rem() ???    <-- YES
	java .../PT runs OK
this~320 above, the adventure into tokenizers  !!!
	this~350 tokenizers seems to have been spun off for future, and effort
	moved to konst, hence up the stack to asgn. Then distracted into antlr.
Going back to Tokens for awhile.
---------------------

Sat, Mar 26
Tokens is stable and tests fine at global level. Does not go into fcn's block. 
Moved back here to use it as a tool. And renamed this tiny-c. I will focus on
that until I have a servicable tc. There are now 2 tiny-c folders, the C version
in Projects/tiny-c and this version on Projects/Java/tiny-c. I probably need to
make some code changes to reflect this new goal and arrangement.
SURVEY...
	src/*.java    all early Feb dates
		why ~s here and also above 
	gj & other cmds
diff PT*    seem to be debugging PT:    ~109 ~123 prints,  ~117 loop changes
	  ^---  ParseTools, extends TJ, all token strings here, lit(), find(), etc.
	debuggin infinite loop in rem
run script: runs Expr, some ~s then FREEZes.  <<-- DEBUGGING target
4 mains, all except TJ.
	Stack not tested yet. Needed by Expr. Stuff is tested.
---
STATUS: Expr runs, konst parses an int 77, and quoted string.
This code CHANGES the f/lname convention from '77 code (incl/incl) to C 
	convention (incl/excl). Hopefully that will simplify things, but BEWARE!!!
Stuff wrappers C/I/Sval have two value getters: toString, and getVal.
	Keep both for awhile.
---
Next goal(s): 
	the asgn...factor stack into expr.
	Works w/ konst:  String test1 "1+2*3"; System.out.println(test);   <<-- 7
		All relns tested true/false and borderline cases...
			1<=2; 1>=2; 1==2; 1!=2;     TFFT
			1<=1; 1>=1; 1==1; 1!=1;     TTTF
			1<2;  1>2;  1<1;  1>1;      TFFF
		Parens in factor...
			(1+2)*3   <<-- 9
	Save work so far as Project/Java/Expression
	Commit/Push to new project: Expression
---------------------

Sun, Mar 27
Above goal ~443: asgn etc into Expr.java
	cp C code into java file
	java-ize
		factor: enuf to call konst, then test w/ numbers, no syms
Subgoal (27 May, 1:30): NEEDed in Expr.reln()...
	Stack tools: topdiff and whatever it needs.
---
STATUS: doing ~460 subgoal. The new stack pushes actual strings onto the stack.
toptoi resolved by returning ptr to the string in pr, knowing it was a C string
due to the trailing " mapped to 0. And it had int<->ptr coerson. What should the
java tc do about string datum for toptoi call? Probably need topType(), and 
toptodatum ??? What code should diagnose   x = 7 <= "foo"   statement ??? Not
stack. Expr.reln() would be proper. So it needs types AND values.
---------------------

Mon, Mar 28
Working on Stack.
	Major change on lvalue: Because the value is part of Stuff an lvalue does
	not have to be resolved. The val itself is changed. And class is now called
	dtod (distance to datum) 0 or 1. These being delicate changes need thinking
	through, carefully.
	BUT for now get Stack to compile and the thorough shakedown.
Stuff/Stack issues/thoughts...
	How to declare the 3 types. They are manifest constants.
	java 5 supports enums. Good read...
	https://docs.oracle.com/javase/1.5.0/docs/guide/language/enums.html
---------------------

Tue, Mar 29
Stuff is stabilized for constants, but NEEDs to support vars.
Back to Stack. STATUS: NEEDs topdiff for use by Expr.reln().
	Stuff needs boolean isInt(), isChar(), isStr()
	Stack then writes    if(top.isInt())...     etc.
LVALUE: resolved in Stack, or Stuff ???  I can face that issue later, for now
	all stack stuff will be constants. Stuff carries the lvalue flag, so it
	may be nice for it to handle in getInt().  
Stuff will know nothing of vartab, and the values are in var now. So lvalue=='L'
must go to the var. '77 tc lvalue=='L' case had a value that pointed into
value space, which was in the call stack. READING enter().
C code: newfun var~6, opens up stack frame. fundone closes it.
	curfun, nxtvar, prused involved. prused was the value space.
Confusion on Stuff flags, esp lvalue. pushst is not setting it
properly. It pushes JUST stuff and returns. But stuff has lvalue
'field' currently TRUE/FALSE. It is tested for 'L' 'A'. Changing to
the latter.
Stuff val is too complicated. Make getters abstract, and test first
then call the right getter. Each val has its own way of returning
a value, each getter a different signature, each abstract in Stuff
itself so it is accessble at the Stuff level.
---------------------

Wed, Mar 30
x	Fixing Stuff.val first
x		Tested
OPEN QUESTION: how does 77 tc handle primitive chars. They are popped as int
using toptoi in C. Does putchar take an int? Should I have a getChar() in Stuff?
Face this question later.
Back to Stack:  working on topdiff()   <-- OK so far
STATUS: works OK on constants, type 'A'. Array code is commented out.
PLAN:
	Study stack in tc code, list work to do
		stack.c: 126 lines
		basic: pushst~38, popst~52
		convenient: topdiff,toptoi,pushk,pushPtr,pushone,pushzero
			the latter 2 are really pushing a boolean, used by reln().
		Have so far: basics, toptoi, topdiff.
		Others are trivial, and can be done when needed.
Decision: Stack is sufficient for now. RETURN to Expr, above~442
	As tested Expr is OK. But the test is shallow: parses 2 constants,
		77 and "foo"
GOAL: parse and compute arithmetic: eg 1+2*3, and (1+2)*3 and more.
	THEN: Do a readline to get the equation, document, push.
DONE:	commit Expr and stabilized Stuff/Stack.
NEXT: test Expr more deeply.
---
ISSUE: Stack.pushPtr~61 pushes an array pointer. dtod is 1. type
may be either. Stuff~33 declares dtod, but it is not used anywhere
until arrays are implemented. Stuff~29 now has an empty Pval which will get
coded then.
x	Stack needs to implement pushPtr(int datum)
---------------------

Thur, Mar 31
Test strategy: more and deeper equations using ints. Call asgn().
toptoi() to get the result.
	pr is declared in TJ~14 as String. The various test mains set
it to whatever, and any code that extends TJ find that. Expr extends
PT which extends TJ.
---------------------

Fri, Apr 1
end of line problems. Expr main needs to be more careful.
asgn given blanks cannot handle that. It assumes a context.
Braces in test string do not help. konst cannot handle it either.
	konst followed by spaces IS OK   "... 11  "
ASSUME for now a proper context will make things good. Adding
cursor test to asgn seems not a good idea. MAYBE a survey of PT
code is needed. Goal now is to finish the 6 relation tests with
a constant and spaces at the end.
---
STATUS: 12 reln test OK
Next: More expr tests, see ~444 above
x		Parens in factor...
x			(1+2)*3   <<-- 9
Then: recode Expr.main as standalone tool, document, push.
ISSUE: If asgn sees a space it goes all the way to factor to
x	realize that, and then advances over ONE SPACE, returns to
x	test code which calls asgn again.   FIXED 
Expr seems solid.
x	commit
Large block of code in factor() commented out. It calls 
symName and var mainly, class 'E' is one line. It calls addrval. To test it
requires the vtab. That seems a reasonable goal. Would not need to parse decls,
var.java main would make calls using quoted names. var.c is the code, 162 lines
excluding dumps. 
---
	newfun~6
	fundone~25
	copyArgValue~39		maybe later
	allocSpace~60		maybe not needed
	newvar~78
	canon~98			ditto
	addrval~131			3 flavors, 2 are support for the ONE used elsewhere.
	dumps~165			maybe not needed
So just framing and newvar and addrval, 4 methods, all public.
---
ISSUE: why an array? Same issue for Stack. Could be a list.
DECision: Var.java is just a list of local hashmaps plus global and
lib hashmaps.
x	Make Stack be a List  
---------------------

Sat, Apr 2
Goal today: var.java
	cp'd from tiny-c
	java-ized, compiles
	test main
	seems OK
---
This impl of tc's variables: 
	Stuff has full description of a var except for its name.
	Stuff has the var's value, so no allocation is needed.
	Hence no need for obsize, which is now gone.
ISSUE on Array:
	Haven't got there yet. But an array must be a List<Stuff>,
	or maybe Stuff[]. Code so far only handles simple Stuff.
Var ready to test. Cases: push several vars into about 5 places
and then retrieve and test them, and do a fundone and retrieve
and print them again. lib1, foo, glb1, bar, nwfun, lcl1, nwfun, lcl2,
foo. THEN lookup each w/ curfun at 2nd local.
	Need to set/get values in some.
---------------------

Sun, Apr 3
x	newfun, fundone, newvar tested OK
x	dumpVarTab OK
x	addrval
---
Studying test.c to determine order of writing the C version.
The big switch is ~168. cases & targets...
			java status: x done, + partial 
+	1	newvar, vartab,	char, varalloc
x	10	stack
+	13	parse tools: skips, rem, konst...
x	17	newvar, vartab, addrval
x	18	expr
	21	decl and asgn, beginning of st(), array, 
	25	MC
	26	if else
	27/8 empty cases
	29	st
	30 up used testfiles, code frags
	34	link
	40	pps lib stuff (ps, pn, etc)
	73 up used bashfiles to run whole progs
Richer st() seems to be next item.
---------------------

Mon, Apr 4
new file: ST.java,    statement,  ST.st(). It needs a few support fcns...
	quit()
quit has an issue: it needs a key listener which in java requires
at least AWT. Goggled "java key listener" and tried one way that
failed. See Projects/TryIt/FIR.java. Looking around for another way.
One fallback is a tiny AWT with just a quit button. Fire up the
console app and get the button on the side. LEAVE THIS WHOLE ISSUE
ASIDE for awhile. ^C does a quit. So focus on... 
---
GOAL: st() executes something minimal, then grow
$ ./gc stcurs
../../tiny-c/tc.c:375:	stcurs=localstcurs;   enter()
../../tiny-c/tc.c:387:	stcurs=localstcurs;   enter()
../../tiny-c/tc.c:765:	stcurs = cursor;      st()
../../tiny-c/tc.c:809:	agin = stcurs;
../../tiny-c/tc.h:117:char* stcurs;
---------------------

Wed, Apr 6
Working on ST, incl decl, varalloc; and PT.symName.
dtod mystery: Studying tc.c code... 
	varAlloc(type,vpassed)
		symName (success required), the tests for '('
		computes vclass,alen, (both local) 
		calls newvar(vclass,type,alen,vpasses)
	newvar
tc.c code: vclass is declared in tc.h, but used only in
varAlloc, and passed to newvar as an arg. TIDYING THES AWKWARDness:
Called dtod now. Declaring as local in varAlloc. 	DITTO alen.
x	Works
	commit
























