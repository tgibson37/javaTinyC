New goal: Use java to rebuild tiny-obj into tiny-j
22 Jan 2022
---
14 toc dot-c files
	src/debug.c   src/facsym.c    src/link.c         src/stack.c    src/var.c
	src/dialog.c  src/factor.c    src/machineCall.c  src/toc.c      src/xray.c
	src/expr.c    src/fileRead.c  src/platform.c     src/tocMain.c
tests in test* dirs and files
	green == bash scripts
	blue  == dirs
tiny-c/test.c may be better study for order of coding
test number:
	1..4: newvar, dumpVarTab
	5: symname, dumpName
	6: _varAlloc, dumpVarTab
	7: _lit
	8: _decl
	9: iProperty  [ReadFile, reads property file]
[to be continued, 77 tests]
==============	
Studying var.c. Goal is understanding needed publics.
	6:   void newfun()
	25:  void fundone()
	78:  void newvar(class,type,len,passed)   <<== constructor
	158: var* addrval()
privates:
	_copyArgValue, _allocSpace, _canon, canon, _addrval, _addrval_all
5 dumps:
	165..211  [Val, funEntry, Fun, Var, VarTab]
==============	
Probably not needed: FileRead, debug
==============
Studying stack.c
	38:   void pushst(,,,)
	52:   stackentry* popst()
	64:   int topdiff()   [used only by reln, tc~474]
	72:   int toptoi()
	106:  void pushk(datum)
	114:  void pushPtr(datum)
	121:  void pushone()
	124:  void pushzero()
privates:
	stuffCopy (one use)
4 dumps:
	3..33 [stackEntry, stack, popTop, top, ]
NOTICE stack always pops int
----------------------------------

Sun, Jan 23
ISSUE: how to implement stuff. It must carry a typeless. C uses a union. There
is no such thing in java. And I bet you cannot do a pointer. It would have
to be a subscript into an array. How to implement...
	char foo(99), ptr(0); ptr=foo      ???
This issue may be fatal to the goal.
Maybe tj can have references instead of pointers. ptr(0) syntax is class 1
in tc and toc. Actually tc pointers ARE references. They have type, size, len.
How to implement stuff ??? What goes onto a stack? You pop a stack and then
examine what you got, type,size,len,class,value. value is the bugger.
	Maybe stuff has all except value, and value is a subclass. HMM!
Datum would be type stuff, and usage of a datum would dig out its value by 
downcasting. Better implement this first as it may be the critical issue to
solve. Do var and stack first. [History repeats itself.]
---
Issue: files. tc.c was separated into a few files in tiny-obj. What are they?
$ ls src/*.c
	src/debug.c   src/facsym.c    src/link.c         src/stack.c    src/var.c
	src/dialog.c  src/factor.c    src/machineCall.c  src/toc.c      src/xray.c
	src/expr.c    src/fileRead.c  src/platform.c     src/tocMain.c
This seems a better structure, especially for public classes. One possibility is
to use tiny-obj as our code source for java, maybe leaving out the object 
extensions. Probably easier is to split tc.c into above. tiny-c has 9 dot-c 
files, (omiting 2 test codes.) Above is 14, but it includes enhancements like xray.
Difference:  facsym, link, factor, xray, expr, platform...
		toc					tc			sizes(K)
	src/debug.c			.debug
	src/facsym.c    	.				 2
	src/link.c         	.				 9
	src/stack.c    		.stack
	src/var.c			.var
	src/dialog.c  		.dialog
	src/factor.c    	.				 9
	src/machineCall.c  	.machineCall
	src/toc.c      		.tc				10, 23
	src/xray.c			.
	src/expr.c    		.				 5
	src/fileRead.c  	.FileRead
	src/platform.c     	.
	src/tocMain.c		.tcMain
xray has no comments. What is it?
	Its a debugging aid, an extension to MC 0. DO LATER, maybe.
---
toc split   -->  facsym, link, factor, expr
=======
Plan tc:
	Use tc code, cp from tiny-c read-only
	split tc to match the toc split into *.java files
	define stuff & descendants, ival, cval, and maybe sval for strings.
	Optionally put value there, too.
=============
var vs stackentry...
	struct stackentry { 
		int class; int lvalue; Type type; 
		union stuff value; 
	};
	struct var { 
		char name[VLEN+1]; int class; Type type; int len; int brkpt;
		union stuff value; 
	};
var reflects what is in the declaration. StackEntry what is
needed for an expression. Notice var has value, which may be
a C pointer to a string. var.value points into value space. 
For class 1 char it	points into the tc program text.
	Can these two decls be made cleaner. In java cannot coerce ints <-> ptrs. 
Use subclasses for value intead of union. For now focus on stack version, and
value is in each subclass Including ref to text. 
---------------------

Tue Jan 25
Working on Stuff.java. char and int OK, string probably needs change when its
role is better understood. Did git init, and committed.
	Cval/Ival classes have toInt(), Sval has toString().
	java Stuff  ->  "7 81 foo-bar"  [3 lines]
java String is immutable. StringBuffer is not. Which should I use for quoted
strings? The tc code in String means cannot change trailing quote to null, but
must extract the string. The former was always a kluge. Hmm.
---
Next goal: stack
---------------------

Wed Jan 26
setting CLASSPATH...
	As root:  $ . ./setClassPath   << my bash script
			$ echo $CLASSPATH
			~/Projects/tiny-j/classes
---
From: https://stackoverflow.com/questions/45309470/how-to-set-environment-variable-classpath-and-noclassdeffounderror-on-linux
    javac ABMain.java
    mv AAA.class ./sub/AAA.class
    mv BBB.class ./sub/BBB.class
    java -cp ./sub:. ABMain
The idea seems to be: 
	subordinate stuff move to ./sub, (I would use ./classes)
	main class stays in tiny-j, and is launched from there
	the -cp means class path with subordinate. NOTE the :.
	I would use:    java -cp ./classes:. Stuff
		and eventually Stack and ultimately tj
	CLASSPATH env var seems to not be involved at all.
---
STATUS of classpath nightmare...
	export CLASSPATH=/home/.../tiny-j/classes     WORKS at user level
	echo $CLASSPATH                               confirms
	erase all *.class files
	javac *.java                         CLASSPATH ignored
	mv *.class classes                   all including Stuff.class
	java Stuff                           runs fine
javac ignores the CLASSPATH, java uses it OK.
How to avoid the mv step? How to make javac embrace the CLASSPATH?
	Found a -cp javac option, man javac, scroll down 2 hits.
	It doesn't work...
NOW HAVE script: ./jc, which does the compile and move.
---
Goal: toptoi and other convenience push/pops.
	A design issue is where to draw the line between Stuff and C primitives.
	For example stack.c uses primitives and builds approprate wrapper as a
	struct stackentry. The line is drawn INSIDE of stack push/pops. The C data
	is needed in expression. Maybe expr() does the unwrapping. But pushone(),
	etc is handy for reln(). Hmm.
		Maybe keep Stuff wrappers a bit higher simplifying push/pop. 
		Add pushk(int), pushone(), etc when needed in expression.
	AND DITTO the funtab stuff. 
	AND eq() needs to resolve an lvalue. Might want to do that soon.
---
Ultra simplified stack.java has just the stack itself, push, pop.
How about expression next. A bit of parsing needed.
---
EXPRESSION...
In tiny-obj expr.c has these fcns...
	asgn
	eq
	reln
	expr
	term
	and uses factor.c 
These are in tc.c~459..675, total 269 lines.
Starting with that code for expr.java.
Doing konst first.  ISSUES:
	_findEOS must return pr subscript
	_mustFind ditto
	DECIDE where are fname,lname converted to a Stuff?
		konst, or new fcn immediately after ?
		Simplest is konst, then return a Stuff which is ample.
Plan: get it to work returning code, than add conversion to Stuff.
STATUS: Wed 7pm: Working on PT.java. 
---------------------

Thur, Jan 27
How to grep with brackets. Use primes AND backslash...
	grep 'pr\[' *.java
	grep '\*cursor' *.java
---
ISSUE: where to put char pr[TJ.PRSIZE] ?
	TJ has manefest constants and some globals, e.g. cursor.
	Stack has the stack.
	cursor,first,last and pr and all parsing should be together.
	PT is parsing tools.
	I'm thinking one big file for pr and all code needing access to it.
	PR.java ???
	Where does main go? java TJ? java TC? 
	When packed into a jar, how is the jar executed ?
		java -jar /../pathToApp
---
import <packageName>
	package statement must be first in file except for leading comments
	or blank lines. My package name would be tgibson37.tinyc.
The package statement in Stuff hides its main, and it wont run.
How to execute a package produced by one file? 
---------------------

Fri, Jan 28
New ~/Projects/Java/Play folder. Goal is to experiment with package directive.
========================= (hiatus) ============================

Sun, Feb 6
Moved tiny-j under ~/Projects/Java.

See ~/Projects/Java/Play/PackageFun for above goal. 
Instead of a makefile I used a few very short bash scripts: 
	setClassPath, jc (compile all), run, clean (remove class files). 
And package name is /tg37/pkgTry. I now understand packaging much better.

STATUS:
	must compile in specific order, so using jc to capture that order.
	So far 2 compiles, the rest fail. NEEDS study why.
		BECAUSE latest changes were not finished/debugged.
pr not declared anywhere. Most usages are in PT.java (parse tools). 
	Where to put? TJ so far is constants. It has NO prereq classes.
		DONE. And stack[] defined in stack.java, too.
---------------------

Mon, Feb 7
GOAL today: retrofit those scripts to tiny-j and package all.
Bit of confusion. The work is in dir Java/tiny-j. The package is tg37/tinyc.
And: going straight to new dir structure.
---
x	move/modify scripts
x		setClassPath
x		clean
x		jc
x		run
x	create dir structure
	edit src to belong to /tg37/tiny, and store under src dir
	test this mess
STATUS:
	6:20am TJ compiles using new dir structure, jc works, clean works
	6:35am Stuff compiles, runs OK 	
	That brings me to the run status of old file structure, ~155 above. 
---
Goal:
	Write Stack test main.
		Stub runs, needs actual test code.
		Const probably needed.
Const
	NEEDS PT
	compiling from cmd line (#'d out in jc)
	konst() should return a Stuff, or null. 
PT
	Needs xcmnt and other x data.
---
Plan:
	Get PT working first
	Then Const
	Then use to write Stack.main tests
---
New Methods: code in PT.java 
	to replace strncmp...
		boolean match(String s1, String s2, int n) {   // arbitrary strings
		boolean matcur(String token){                  // to cursor 
New shell scripts:  gj sym, gc sym  --  Grep java/C code
---------------------

Tue, Feb 8
STATUS
	./setClassPath  sets to this works cls
	./jc compiles Stuff,TJ,Stack
	./clean removes class files
	./run runs Stack.main which is a stub. No test code yet.
	./gc sym greps the tiny-c source for sym
	./gj sym ditto for java source
Current work
	Using $ javac -d cls src/tg37/tinyc/PT.java to java-ize PT
	strncmp PT~17, replace with appropriate match(): ~15,21
WONDERING if TJ should define tools like eset() and the match()'s ???
	They use lots of TJ-dot, e.g. TJ.xcmnt.
	The goal of a tool class is to make algorithms easy to code. All those
		TJ-dots make for messy typing AND reading.
	In effect merge TJ and PT.
	A downside is all the parse tools become TJ.lit(TJ.xcmt)), for example.
	So include that, too. Conclusion is layered code does not map into
	classes unless you want to XX-dot everything. 
EXTEND is the solution. PT extends TJ. All the TJ-dots disappear !!!
	Higher layers extend lower layers, adding to them. But watch out names.
	You lose the separation of name spaces. Not an issue for this project.
---
pr+cursor doesnt work. pr is char[], cursor is int.
pr.substr(cursor) may work if pr is a String.
STRING pr: Read file line-at-a-time appending into StringBuffer. Return 
buffer.toString() which is done efficiently, no copying. Now tokenizing is
done using substring, compareto, and more.
---
It seems to me that matching will be easier to write if all the pr text is
an array of String tokens. How hard is it to write a tokenizer? One pass over 
the read buffer into String token[]. Can I expand an array? Assume yes for now.
First char is:
	comment --  pass over
	alpha  --  continue through alphanums
	const  --  continue thru the constant
	()[]   --  single char
	ops    --  test for 2 chars
Do a line at a time. 
	FUTURE: 1st byte is token type.
		matching []'s point to each other.
		fcn call points to the fcn decl.   MAYBE MORE
---------------------

Wed, Feb 9
Working on Token.java
ArrayList~502 has addAll(Collection)
STATUS 1 pm: parses alphas & numbers. COMMITTED. And tidied. 
NEED to add more types:
	constants, operators, structure: {}[](), puctuation, other. Is that all ???
	Add one at a time and let the tokenizer decide.
AND: A small struct with just the type and token is what should be in token[].
QUESTIONS: should I continue with arrays or should I use ArrayList ???
---------------------

Thur, Feb 10
Back from Tokenizer, which is now in ../Java/Tokenizer. A copy is here as
a package member.

~282 STATUS is handy
	~290 has javac for PT, PT extends TJ. NEED TJ.class
	cls has only Token.class
ALL fixed, ./jc now compiles PT with errors  <<==  AGENDA
./jc now writes error file and does head -n 40
---------------------

Fri, Feb 11
PT compiles. No main.
STATUS
	./jc compiles Stuff,TJ,Stack,PT  <<== EVERYTHING
	Token was moved to Projects/Java/Tokenizer, not in any package.
Const next...
	konst returns Type, not boolean. Type==0 means false.
---
Thoughts: 
Building a parse tree might be fun. A [] block would contain ALL the
statments withing the block. An fcn defn would have a Stuff of type FCN with 
return type, name, args, body: 4 elements. Constants would be type and value: 
ints would be parsed once at parse time, and value held as a java/C/whatever
integer.
---
Structures:
	TJ <- PT <- Const 
	Stuff <- [S,C,I]val
	Stack
Expression Parser~393..675
	asgn, expr, term, factor, konst  
Rename Const.java -> Expr.java and do all 5 classes.
Combine Stack and Stuff. OR put stuff into TJ.
        ???        ???        ???        ???
PLAN:
x	Rename Const -> Expr
x		Get it to compile
		Design/code tests in main()
	Add expression stack but factor does ONLY constant.
	USES pushk & toptoi, so Stack gets tested, too.
---------------------

Sat, Feb 12
A choice of goals: 
	Work on tokenizer project until it can tokenize a tiny-c, C, or Java program.
	Finish the java version of tiny-c.
	The former gives me a nice publishable tool. The later a workable tiny-c.
	But I can do tiny-c on my laptop, maybe. And the latter may be useful in
	the former, giving it more purpose.
Today I think I will do the tokenizer.
---------------------

Thur, Mar 24   --   (six week hiatus)
With my C platform crashed I return to java. Recalling the status here...
	No cmds file, but gc, gj, jc
	jc compiles PT.java and Expr.java, and had also done Stuff & Stack.java.
	gc/j greps code in two places: ../../tiny-c and ./src/tg37/tinyc/*.java
	Setup: setClassPath sets to local cls dir only.
Studying ~50 above, Stuff. 8080 code everything was an int when popped, but
stack data described it. So Stuff is what is pushed/popped. 
tc's class changed to dtod (distance to datum), 0 or 1. Avoids confusion.
	3 subclasses: Sval,Cval,Ival hold respect. These ARE the values, there is
	no value space allocated in pr.
at ~184 above...
	java Stack               <<-- "could not find..."
	java tg37.tinyc.Stack    <<-- WORKS
---
$ java tg37.tinyc.Expr
running Expr.main0 11
 ~9 ~109             <<==   FREEZes
 	This must be my most recent status for tiny-c. 
 		~109 is in PT.java, rem.
 		pr code is set in Expr~46 to:   "  77  foo  "
 		~109 is while loop in rem() and ~123 when loop is done doesn't print.
so konst() must call rem() ???    <-- YES
	java .../PT runs OK
this~320 above, the adventure into tokenizers  !!!
	this~350 tokenizers seems to have been spun off for future, and effort
	moved to konst, hence up the stack to asgn. Then distracted into antlr.
Going back to Tokens for awhile.
---------------------

Sat, Mar 26
Tokens is stable and tests fine at global level. Does not go into fcn's block. 
Moved back here to use it as a tool. And renamed this tiny-c. I will focus on
that until I have a servicable tc. There are now 2 tiny-c folders, the C version
in Projects/tiny-c and this version on Projects/Java/tiny-c. I probably need to
make some code changes to reflect this new goal and arrangement.
SURVEY...
	src/*.java    all early Feb dates
		why ~s here and also above 
	gj & other cmds
diff PT*    seem to be debugging PT:    ~109 ~123 prints,  ~117 loop changes
	  ^---  ParseTools, extends TJ, all token strings here, lit(), find(), etc.
	debuggin infinite loop in rem
run script: runs Expr, some ~s then FREEZes.  <<-- DEBUGGING target
4 mains, all except TJ.
	Stack not tested yet. Needed by Expr. Stuff is tested.
---
STATUS: Expr runs, konst parses an int 77, and quoted string.
This code CHANGES the f/lname convention from '77 code (incl/incl) to C 
	convention (incl/excl). Hopefully that will simplify things, but BEWARE!!!
Stuff wrappers C/I/Sval have two value getters: toString, and getVal.
	Keep both for awhile.
---
Next goal(s): 
	the asgn...factor stack into expr.
	Works w/ konst:  String test1 "1+2*3"; System.out.println(test);   <<-- 7
		All relns tested true/false and borderline cases...
			1<=2; 1>=2; 1==2; 1!=2;     TFFT
			1<=1; 1>=1; 1==1; 1!=1;     TTTF
			1<2;  1>2;  1<1;  1>1;      TFFF
		Parens in factor...
			(1+2)*3   <<-- 9
	Save work so far as Project/Java/Expression
	Commit/Push to new project: Expression
---------------------

Sun, Mar 27
Above goal ~443: asgn etc into Expr.java
	cp C code into java file
	java-ize
		factor: enuf to call konst, then test w/ numbers, no syms
Subgoal (27 May, 1:30): NEEDed in Expr.reln()...
	Stack tools: topdiff and whatever it needs.
---
STATUS: doing ~460 subgoal. The new stack pushes actual strings onto the stack.
toptoi resolved by returning ptr to the string in pr, knowing it was a C string
due to the trailing " mapped to 0. And it had int<->ptr coerson. What should the
java tc do about string datum for toptoi call? Probably need topType(), and 
toptodatum ??? What code should diagnose   x = 7 <= "foo"   statement ??? Not
stack. Expr.reln() would be proper. So it needs types AND values.
---------------------

Mon, Mar 28
Working on Stack.
	Major change on lvalue: Because the value is part of Stuff an lvalue does
	not have to be resolved. The val itself is changed. And class is now called
	dtod (distance to datum) 0 or 1. These being delicate changes need thinking
	through, carefully.
	BUT for now get Stack to compile and the thorough shakedown.
Stuff/Stack issues/thoughts...
	How to declare the 3 types. They are manifest constants.
	java 5 supports enums. Good read...
	https://docs.oracle.com/javase/1.5.0/docs/guide/language/enums.html
---------------------

Tue, Mar 29
Stuff is stabilized for constants, but NEEDs to support vars.
Back to Stack. STATUS: NEEDs topdiff for use by Expr.reln().
	Stuff needs boolean isInt(), isChar(), isStr()
	Stack then writes    if(top.isInt())...     etc.
LVALUE: resolved in Stack, or Stuff ???  I can face that issue later, for now
	all stack stuff will be constants. Stuff carries the lvalue flag, so it
	may be nice for it to handle in getInt().  
Stuff will know nothing of vartab, and the values are in var now. So lvalue=='L'
must go to the var. '77 tc lvalue=='L' case had a value that pointed into
value space, which was in the call stack. READING enter().
C code: newfun var~6, opens up stack frame. fundone closes it.
	curfun, nxtvar, prused involved. prused was the value space.
Confusion on Stuff flags, esp lvalue. pushst is not setting it
properly. It pushes JUST stuff and returns. But stuff has lvalue
'field' currently TRUE/FALSE. It is tested for 'L' 'A'. Changing to
the latter.
Stuff val is too complicated. Make getters abstract, and test first
then call the right getter. Each val has its own way of returning
a value, each getter a different signature, each abstract in Stuff
itself so it is accessble at the Stuff level.
---------------------

Wed, Mar 30
x	Fixing Stuff.val first
x		Tested
OPEN QUESTION: how does 77 tc handle primitive chars. They are popped as int
using toptoi in C. Does putchar take an int? Should I have a getChar() in Stuff?
Face this question later.
Back to Stack:  working on topdiff()   <-- OK so far
STATUS: works OK on constants, type 'A'. Array code is commented out.
PLAN:
	Study stack in tc code, list work to do
		stack.c: 126 lines
		basic: pushst~38, popst~52
		convenient: topdiff,toptoi,pushk,pushPtr,pushone,pushzero
			the latter 2 are really pushing a boolean, used by reln().
		Have so far: basics, toptoi, topdiff.
		Others are trivial, and can be done when needed.
Decision: Stack is sufficient for now. RETURN to Expr, above~442
	As tested Expr is OK. But the test is shallow: parses 2 constants,
		77 and "foo"
GOAL: parse and compute arithmetic: eg 1+2*3, and (1+2)*3 and more.
	THEN: Do a readline to get the equation, document, push.
DONE:	commit Expr and stabilized Stuff/Stack.
NEXT: test Expr more deeply.
---
ISSUE: Stack.pushPtr~61 pushes an array pointer. dtod is 1. type
may be either. Stuff~33 declares dtod, but it is not used anywhere
until arrays are implemented. Stuff~29 now has an empty Pval which will get
coded then.
x	Stack needs to implement pushPtr(int datum)
---------------------

Thur, Mar 31
Test strategy: more and deeper equations using ints. Call asgn().
toptoi() to get the result.
	pr is declared in TJ~14 as String. The various test mains set
it to whatever, and any code that extends TJ find that. Expr extends
PT which extends TJ.
---------------------

Fri, Apr 1
end of line problems. Expr main needs to be more careful.
asgn given blanks cannot handle that. It assumes a context.
Braces in test string do not help. konst cannot handle it either.
	konst followed by spaces IS OK   "... 11  "
ASSUME for now a proper context will make things good. Adding
cursor test to asgn seems not a good idea. MAYBE a survey of PT
code is needed. Goal now is to finish the 6 relation tests with
a constant and spaces at the end.
---
STATUS: 12 reln test OK
Next: More expr tests, see ~444 above
x		Parens in factor...
x			(1+2)*3   <<-- 9
Then: recode Expr.main as standalone tool, document, push.
ISSUE: If asgn sees a space it goes all the way to factor to
x	realize that, and then advances over ONE SPACE, returns to
x	test code which calls asgn again.   FIXED 
Expr seems solid.
x	commit
Large block of code in factor() commented out. It calls 
symName and var mainly, class 'E' is one line. It calls addrval. To test it
requires the vtab. That seems a reasonable goal. Would not need to parse decls,
var.java main would make calls using quoted names. var.c is the code, 162 lines
excluding dumps. 
---
	newfun~6
	fundone~25
	copyArgValue~39		maybe later
	allocSpace~60		maybe not needed
	newvar~78
	canon~98			ditto
	addrval~131			3 flavors, 2 are support for the ONE used elsewhere.
	dumps~165			maybe not needed
So just framing and newvar and addrval, 4 methods, all public.
---
ISSUE: why an array? Same issue for Stack. Could be a list.
DECision: Var.java is just a list of local hashmaps plus global and
lib hashmaps.
x	Make Stack be a List  
---------------------

Sat, Apr 2
Goal today: var.java
	cp'd from tiny-c
	java-ized, compiles
	test main
	seems OK
---
This impl of tc's variables: 
	Stuff has full description of a var except for its name.
	Stuff has the var's value, so no allocation is needed.
	Hence no need for obsize, which is now gone.
ISSUE on Array:
	Haven't got there yet. But an array must be a List<Stuff>,
	or maybe Stuff[]. Code so far only handles simple Stuff.
Var ready to test. Cases: push several vars into about 5 places
and then retrieve and test them, and do a fundone and retrieve
and print them again. lib1, foo, glb1, bar, nwfun, lcl1, nwfun, lcl2,
foo. THEN lookup each w/ curfun at 2nd local.
	Need to set/get values in some.
---------------------

Sun, Apr 3
x	newfun, fundone, newvar tested OK
x	dumpVarTab OK
x	addrval
---
Studying test.c to determine order of writing the C version.
The big switch is ~168. cases & targets...
			java status: x done, + partial 
+	1	newvar, vartab,	char, varalloc
x	10	stack
+	13	parse tools: skips, rem, konst...
x	17	newvar, vartab, addrval
x	18	expr
	21	decl and asgn, beginning of st(), array, 
	25	MC
	26	if else
	27/8 empty cases
	29	st
	30 up used testfiles, code frags
	34	link
	40	pps lib stuff (ps, pn, etc)
	73 up used bashfiles to run whole progs
Richer st() seems to be next item.
---------------------

Mon, Apr 4
new file: ST.java,    statement,  ST.st(). It needs a few support fcns...
	quit()
quit has an issue: it needs a key listener which in java requires
at least AWT. Goggled "java key listener" and tried one way that
failed. See Projects/TryIt/FIR.java. Looking around for another way.
One fallback is a tiny AWT with just a quit button. Fire up the
console app and get the button on the side. LEAVE THIS WHOLE ISSUE
ASIDE for awhile. ^C does a quit. So focus on... 
---
GOAL: st() executes something minimal, then grow
$ ./gc stcurs
../../tiny-c/tc.c:375:	stcurs=localstcurs;   enter()
../../tiny-c/tc.c:387:	stcurs=localstcurs;   enter()
../../tiny-c/tc.c:765:	stcurs = cursor;      st()
../../tiny-c/tc.c:809:	agin = stcurs;
../../tiny-c/tc.h:117:char* stcurs;
---------------------

Wed, Apr 6
Working on ST, incl decl, varalloc; and PT.symName.
dtod mystery: Studying tc.c code... 
	varAlloc(type,vpassed)
		symName (success required), the tests for '('
		computes vclass,alen, (both local) 
		calls newvar(vclass,type,alen,vpasses)
	newvar
tc.c code: vclass is declared in tc.h, but used only in
varAlloc, and passed to newvar as an arg. TIDYING THES AWKWARDness:
Called dtod now. Declaring as local in varAlloc. 	DITTO alen.
x	Works
x	commit    (just varAlloc)
---
NEXT: link as fcn in Var
---
struct funentry *fun, tc.h~78. 
	fun,curglbl,curfun,efun are all ptr to funentry
	newfun/fundone must be involved. All part of Var.
	fun IS the fun table. Should be called funtab. Others pnt to 
		sections of the table.
Don't need curglbl, etc. Not even fun. The Map/List containers are
sufficient. newnum and fundone are complete and tested. So all those
pointers have no equivalent in this version except curfun which jumps
around to different maps. NEED: addrval java-ized.
---
STATUS: goal is big-bang compile, incl link(). Then do TC.main which should drag
in whatever else is needed to complete. 
---
Confusion stack vs vartab: Stuff designed for stack data. 
	NEED to create function entry for vartab. Stuff.Type.FCN
class Var IS a variable, and its 3 containers, too. Var data is
taken from tc's struct var. 
x	Var should NOT extend PT. It is not a parse tool.
	Needs constructor.
	Probably the containers should be in their own class, not Var itself.
		Vartab ???
---------------------

Fri, Apr 8
Broadening the role of Stuff so it can be used as part of a Var.
But Var includes function, so...
x	A Var has Stuff in it. Stuff has 4 types: INT,CHAR,STR,FCN
	Move useless getters out of Stuff into the derivative.
	Always test the type before calling a getter.
Thought: dtod should be boolean isArray
---------------------

Sat, Apr 9
Working to get a compile for...
	Stuff
	Var
	All
new Ival issue ???  Going to clean dir, Java/TryIt
	TryIt goal is smallest code that has the non-static complaint.
	Complaining about use of nonstatic var in constructor.
---------------------

Mon, Apr 11
STATUS: Now have Stuff.java and Stuff.bak, an older version. And 2 dot-baks.
One is in Projects/TryIt. 
	Another in Projects/Java/TryIt. This latter one is where I experimented with
cloning, and got some evidence how to make sub classes cloneable.
	Then I wondered do I need cloning at all? Var is a variable description
and goes into var tables. Stuff is a value description and goes onto the Stack.
A Var has a Stuff which has the Var's value. eq() will be involved. A Stuff will
need a value setter.
PLAN is to not do a clone, but role foreward towards a working asgn() in Expr.
But which of the Stuffs is the base? Grep the various source dates.
	Stuff.java~			 Jan 27 14:20    1693 bytes [d0]
	src/*/*/Stuff.java~  Apr 8, 08:52 	 3588		[d1 diff]
	Stuff.bak			 Apr 9, 08:56    3603		[d2 diff]
	src/*/*/Stuff.java   Apr 9, 12:15	 3994		[d3 diff]
d0: dtod,lvalue,type,len,getInt(). Manifests all int. Sval,Cval,Ival. 
d1: isarray, "    "   " ,toStrinng(), many getters, enum manifests.
d2: ~52,103 changes. vc commented out. Ival's super(..) commented out.
d3: tons of changes. booleans instead of enums. richer constructors. Base vs
derived class details sorted out. This IS the latest and probably the best and 
the only dot-java (others are bak or ~). Pval derivative commented out. Not sure
it is needed. All tests OK.
---
Goal: Run all tests one at a time.
x	Stuff
x	Stack
	Expr	fails
x	PT
	TJ	(no main)
x	Dialog
x	ST
	Var		fails
----
x	NEED getInt() abstract in Stuff and invalid calls eset(TYPEERR).		
	Issue: what is diff between Stack and StackImpl. NEED peekTop USAGE.
---------------------

Tue, Apr 11
Working on Expr. Stuff and Stack seem settled down.
8am: Expr also OK, ditto PT, and now (noon) Var.
File toc:
	PT		x.. Strings,f/lname,lit,symNames,finds,rem
	TJ		eset,PRSIZE,pr indices, error/at, cursors, leave,brake, 
		another f/lname, type flags, error tags
	Dialog	countch,errToWords,f/lchar,whatHpnd,showLine,simple prints,logo
	ST		st,quit,skip,decl,varAlloc
	Stuff	type,len,lvalue,isArray,Stuff(.),getType/Int,isXxx,createI/C/Fval,
		S/C/I/P/Fval
	Stack	stack,pushst/k/Ptr/one/zero,popst,topdiff,toptoi,StackImpl
	Expr	asgn..factor,konst
	Var		isArray,type,len,value;containers:lib,globals,locals;newfun,fundone,
		copyArgValue,Var,addrvals,peekTop,dumps,tclink
---------------------

Wed, Apr 13
NEXT: tcMain.c, 200 lines. main is ~183, 20 lines, lots of dash options: lqdvr.
Postponing those, the logic is:
	allocStuff
	cp seed code
	set cpr,endapp,prused indices beyond the seed
	set cursor & curglbl
	load default library, mark end
	load app code
	set nxtvar, nxtstack, curfun
	logo
	link
	setcursor
	st()
	whatHappened
allocStuff~148   probably mute because we use java containers
	prlen [check pps/tc.prop for override]
	funlen [ditto]
	stacklen [ditto]
	vtablen [ditto]
java version may start out much simpler:
	cp seed code
	load code: lib and app
	set whatever
	link
	st
	whatHappened
Hmm. Code from scratch, and use tc.c as reference, not code to java-ize ???
New file: TC.java
---------------------

Thur, Apr 14
STATUS: TC.java reads foo.tc and prints it.
GOALs:
x	TC: full load of pr incl seed, pps/library.tc, xendlib, foo.tc
	foo.tc uses ps, links and runs OK
	survey for commented out TODO code, and bring them up
---------------------

Mon, Apr 18, Happy Easter
Status: discovering status. ~800 above is the goal. New code in TC, ST, Var.
Running	TC with foo.tc arg as test. 2:45pm running now, but tclink produces
empty dumpVarTab. STATUS: debugging tclink, Var~119.
---------------------

Thur, Apr 21
Status: debugging tclink. Infinite loop. Running...
	./r TC foo.tc
	foo just pl's a String
	lpr/apr/EPR all OK
	issue is in checkBrackets
		lpr: cursor 9...5500, error 0
		GLOBALS: 5500...???, error 2023, cursor DID NOT ADVANCE
---------------------

Fri, Apr 22
The only foo.tc global is foo itself.  
	The first bracket test is the seed, cursor = 0..9
	The second test is libs, 10..5500 which includes the 'endlibrary'
		Is pps/library.tc 
	The third test is the app, foo.tc. It is never reached.
	Why both EPR and endapp? 
		Both in TJ~15, legacy from data being in pr from endapp to EPR.
			24 endapp hits, 7 EPR
---------------------

Thur, Apr 28
Dumps in TC,Var show only 
	ONE symbol hit (Var~156)
	One entry in libs, none in globals  [dumping map.size()]
		dump of the one needs work      <<<===  Var~
	SHOULD have all libs, and two globals: foo, main
x		BUT foo needs a main.
	WHY is the loop not looping ???
---------------------

Fri, Apr 29
getproperty is 1st lib sym and ONLY in lib map. 
x	Cursor must run to end of pr before 2nd pass of while: Var~142
2 bugs found/fixed today (8am)...
	ran TC.main:    ./r TC foo.tc
	dumped libs and globals maps. Being hashfiles the dumps have random order.
		But the content is proper
	Uncovered TC~62: ST.st(), it did nothing. Probably missing code. SO...
Goal: Actually execute the seed, main, and foo.
	Need to read ST.st(): ST~15. 
x	Need to tidy Var, etc.
	Getting LINKERR running ./r TC foo.tc
		Parses seed's '[', in xlb loop ST~30 cursor is 1:  --> "main();]" 
		Linking is history. Should enter st() again, tunnel down to factor and
			symbol, look up 'main', and do enter().
Study the code starting at ST~30...
STATUS: error is set in tclink. TC~45,49 bracket the call
	printing error: 0 then 20.
	Code goes on running: ST~'s   15  20  28,29  30,31,32
		in st() -------------------^   ^   ^  ^   ^  ^  ^
		before rem() ------------------J   |  |   |  |  |
		xlb match -------------------------+--J   |  |  |
			xlb for loop -------------------------+--+--J
---------------------

Sat, Apr 30
Most likely I need to set endapp just past the last ] instead of == EPR. It 
should never start that last loop.
	Didn't work. tclink works but ALWAYs sets LINKERR, probably in last pass.
	cursor points to final ] on last pass. cursor needs to be bumped PAST the
	the last matched ], but where ???
		skip works fine until end. 
		foo.tc has a \n at end.
		tclink's last call to skip was the match of global 'main'
Try jdb SS from the match of main...
	$ jdb tg37.tinyc.TC foo.tc
	> stop at Var:148      <<--  deferred, ~148 is match of endlibrary
	> run                  <<--  ran to end, no hit on 148
Also: cont for continue, stop in Class.methodSignature
---------------------

Mon, May 2
Suspicion: skip block is stopping one short, ST~164, calls from ST and Var.
	TRUE, auditing all calls...
	ST~142	skipst, compound case, followed by rem call 
	 148	skipst, if/while case, optional ()'s around the args.
	 167	defn
	VAR~114	checkBrackets, cursor at end is irrelevant
	 144	tclink skip fcn body case, bump here may be best fix
	 164	tclink symname case, skip fcn body
Philosophical question: am I cloning code as done in priors, or am I tidying
	awkwardly done stuff like skipst ??? It would be better if it moved the
	cursor just beyond the matching 'char r.'
	AND this worked once in prior C version, and 8080. How do these these 3 impls
		line up ???
	Thought: get it to work as is for now, then consider doing a total 'tidy
		audit' and overhaul...   vs    I'm into this issue now, get it right:
		working AND tidy. I THINK THE LATTER IS BEST. ~884 audit above is a good
		starting place. How should each end up ???
	ST~167: cursor should be JUST beyond matching r.
	Others: conform to new defn.
		ST~142	OK as is
		148		study:	looks iffy even as is
		Var~114	OK as is
		144		study:	OK as is
		164		study:	IMPROVED, this is the bug
8080 skipst, App A ~282C.
	rem(), lit [, skip [], skip if-else nested.  BUT NOT while ??? 
	My guess is it was coded to served only where needed. All calls to skipSt
	are from ST, ~'s 56, 60, 85, 95, 149, 151     java version.
		from tc.c    691, 693, 787, 791, 815, 825
x	6 total uses. DECISIONS: BUMP the cursor PAST the matching r. Fix later
x		if anything breaks.
---------------------

Tue, May 3
THOUGHT: should eset call whathappened and exit ???
Yesterday added the bump at ST~177, today compiled, 
	run crashed: Stack~96. error stayed 0. So above fixed and have new issue.
x	Lots of output. Removing err prints in Var~135..141, TC~49. 
x	Goal is clean run to the new issue.
Issue: debugging st. Stack to crash point...
	at tg37.tinyc.StackImpl.pop(Stack.java:96)
	at tg37.tinyc.Stack.popst(Stack.java:18)
	at tg37.tinyc.Stack.toptoi(Stack.java:33)
	at tg37.tinyc.ST.st(ST.java:115)	in st, after Expr.asgn()
	at tg37.tinyc.ST.st(ST.java:32)		in xlb loop, calls st()
	at tg37.tinyc.TC.main(TC.java:53)	calls st()
		cursor is 1
		probably Expr.asgn pushed nothing. 
			Should have matched 'main' and looked up and entered.
Exactly what path ???
x	Plant a print deep to see if it is first hit...
x	st~32, xlp loop calling st()
		cursor -> main();]
		SO: st got into seed's [], is trying to process 'main'
---------------------

Wed, May 4
PLAN: use jdb, bkpt ST.st:34 (just before loop's st call), then single step...
	What should happen: 
		st down to Expr.asgn to factor, to symbol, match 'main,' addrval,
		is an 'E', enter.
GOAL: where did it go off the track ???
---------------------

Thur, May 5
Did it get to factor? Have I javanized all of Expr?   <<==  probably, and NO.
	factor can do only constants, symName is covered.
Var usage... 
	Var v = addrval(fname,lname); // searches locals,globals,libs
	Stuff s = v.value();  // returns Xval, X= I, C, S, F.
		both uses are tested in Var.main.
Expr...
	test cases use only constants, 
	no code for Var details, BUT  
Stuff...
	boolean isNum(),isInt(),isChar(),isStr(),isFcn()
	abstract getInt() 
		eset(TYPEERR) for Sval, returns -999999.
		kursor for Pval and Fvar.
Var has value, and it is public, so no getter/setter.
	E.g: Var~200.
---
I need to document the API for each main class, with summary paragraphs.
x	api.txt
---------------------

Fri, May 6
STATUS: ./r TC foo.tc crashes, peekTop. 
	Its running fresh code, never run before.
		ST~32, xlb loop calling st, cursor->main();]
		factor~165
	So it got that far at least. Need to study code from there to crash point.
		Stack~103
Its tunnelling out of asgn stack, and expr~84 expects a value returned from 
below. The cursor points to 'main' (in the seed). That should have been entered.
So what happened in factor: expr~165 ???
---
added 'dump' script to tc source, tab 2 of cmd window.
	FROM THAT tab ./dump compares times of src vs classes.
---     back to ~978 above...
factor should have parsed main, looked it up, entered. Reading the code...
	expr~165: 
That code is fresh C, not java-ized yet.
	Stuff:	public boolean isArray;    // used to be int class
		tons of hits via ./gj
		note isArray is public, no get/set.
			All the classes are really just public structs with code.
			Stuff and Var are the only objects. 
typeToSize, tc.c~45, computes byte size for storage purpose.
	BUT Stuff holds the value. Does that include the whole array?
		It must. No other place to put it this java design.
		So accessing an element must be handled by Stuff, not client code.
		Have not yet parsed an array, so Hmm.
PLAN: do arrays later. Get foo to call pl, and pl to do its thing.
x	Expr~7: enter(int where)...    <<== stub
ASSUME: typeToSize is obsolete.
STATUS: stub enter sets cursor and calls st(), nothing more.
x	The seed does call main, and foo is parsed but not its arg yet.
x	The cursor -> char b(0     <-- the arg to ps
Goals: 
	full enter incl MC call, 
	then new file MC.java with ps.
Stack.java has implied nxtstack: StackImpl.list.size()
C version enter manipulates nxtstack building the args.
	varargs complicates things. Maybe skip for now ???    YES
---------------------

Sat, May 7
Abandon enhancements to Expr.main, too messy.
Restored Expr.main to original test code, all 3 pr OK now.
Status: working on full enter, ~1003 above.
Test run:   .r TC foo.tc
	loadCode, tclink, st
Changes to Stack are getting messy. Stack has static methods. StackImpl is
new'd up at ~10. Expr.enter needs to get size of StackImpl.list which IS the 
stack. ~92 error complains about non-static variable list. Stack should offer
a static size(), StackImpl should be hidden, private to Stack.
	./r Stack runs OK, will need size test case added.
Goal: Stack.size() method, Then use it in Expr.enter().
ISSUE: jc complains Stack~91: static flaw...
	static List cannot hold non-static Stuff  ???
---------------------

Sun, May 8
I'm thinking it is time to make my container classes be singletons instead
of all those static methods. Also TJ error codes should be final. Issue is when
to do it, now or after enter() is finished. I think maybe now. But I need
closure on changes so far, specically good compiles. Do that easily by
covering not fixing erroneous code.
x	Stack ~91
x	Expr ~11,36,37
x	Full compile, (12 seconds)
https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples
PLAN: Make these files self instantiated singletons.
		Use above ref method 4: Thread safe. Same as my old usage except the
			synchronized attribute on getInstance(). 
x	Stack
	Expr
	ST
	PT
	do getInstance() calls with local refs where needed. E.g...
		Dialog di = Dialog.getInstance();
		PT pt = PT.getInstance();
		di.errToWords()   instead of   Dialog.errToWords()
		pt.xif            instead of   PT.xif
	find all refs to calls and use above technique
	AND change names of the two letter classes, e.g. 
		ParseTools.java instead of PT.java...
			ParseTools pt = ParseTools.instance();
---------------------

Mon, May 9
Moving from static to singleton, ~1039 above
	Stack done, Expr next.
---------------------

Tue, May 10
First mentions of each src...
	Feb 7:  git     "5 source files"
	Feb 11: git     "PT compiles"
	Mar 30: git     "Expr parses constants,     Stuff and Stack stabilized"
	Apr 2:  git     "Var compiles"
		notes...
	Jan 25: Stuff   notes~119
	Jan 26: PT          193
	Feb 6:  TJ          254
	Feb 7:  Stack       259
	Feb 8:  tools: setClassPath,jc,clean,r,gc,gj
	Feb 11: Expr        366 (just Konst)
	Mar 24: SVal,etc    398, subclasses extend Stuff
	Apr 2:  Var         589
Test mains...
	Stuff
	PT
	Stack
	TC	 (loadCode, overall test main)
	Expr (relations)
	Var  (tc.link, newfun, etc.)
---------------------

Thur, May 12
More study/doc: role of each source
		Unit test mains: Expr,PT,Stack,Stuff
	Stuff	data
				base for Sval,Cval,Ival,Pval,Fvar
	PT		parse tools
				base for Dialog,Expr,ST,Var
	TJ		variables, constants, eset()
				base for PT,Stack
	ST		statement parser (st)
	TC		loader, system test main
	Dialog	dialog
	Stack	stack
	Expr	expression
	Var		variables, their container, tclink
Goal: Singletons for...
	ST
	TC
	Dialog
x	Stack
	Expr
Conversion steps: doing Expr
	4	Change calls everywhere from class to instance
			use compiler or ./GJ to find them
			use getInstance for handle
	5	run all tests
---
	Expr calls are all in ST.
	Doing step 4 first.
Steps: doing Expr...
x	1	find client calls and cnange to instance calls
x			(ST: ~4, and replace Expr->ex)
x	2	Expr.getInstance() code   (see Stack~9..15)
x	3	getInstance call in Expr.main   (Stack~79)
x	4	remove static on fcn/data definitions
	5	run unit test
---
Var cannot be a singleton. Maybe split it in two:
	the container Vartab, a singleton
	the variable Var
AND meaningful rename the singletons: ST PT TJ TC
---------------------

Fri, May 13
Divided Var.java into Vartab and Var source files.
Var~74, curfun = ..., is a mystery. What did this line of code do?
---------------------

Sat, May 14
covered the mystery code line, compiling all...
Compile all line added to ./jc. Works fine. 
	tab 2 dump: ls -l both src and cls: ALL COMPILES Ok, 7:40am.
Goal: run ALL tests. mains:
	Expr
	Stack
	Stuff
	TC foo.tc
	Var
runall:  script to run above mains
	opens with clear and echo "===..==" as start marker
	and separates each call with echo "---..--^^<classname>"
Goal: "running xxx" at start of each test main.
x	HAVE: Expr,Stack
x	NEED: Stuff,TC,Var
Goal: uncover TC~56 call to stmt.st()
	What it does: load code(arg), link, dump vartab, cursor=0 (->seed), st()
	short: try to run a tc program (foo.tc ~1139 above)
	./r TC foo.tc   GOOD up to st call. 
		TC~49 print shows error 0
		BUT no further output. 
Goal: trace the st call.
	The link vardump is good.
	Expr has 3 ~ dumps: 226..238 (factor,factor,isFcn)
	enter() is empty stub w/ nearby covered tc code.
Goal: get enter working
STATUS: Only ABOVE code is copied, and is still tc, not java.















